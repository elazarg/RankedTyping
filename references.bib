@inproceedings{SiekTaha2006,
  author    = {Jeremy G. Siek and Walid Taha},
  title     = {Gradual Typing for Functional Languages},
  booktitle = {Proceedings of the Scheme and Functional Programming Workshop},
  year      = {2006},
  pages     = {81--92},
  address   = {Chicago, IL},
  note      = {University of Chicago TR-2006-06}
}

@inproceedings{SiekGarciaTaha2015,
  author    = {Jeremy G. Siek and Ronald Garcia and Walid Taha},
  title     = {Refined Criteria for Gradual Typing},
  booktitle = {SNAPL 2015: Summit on Advances in Programming Languages},
  series    = {LIPIcs},
  volume    = {32},
  pages     = {274--293},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
  year      = {2015},
  doi       = {10.4230/LIPIcs.SNAPL.2015.274}
}

@inproceedings{GarciaClarkTanter2016,
  author    = {Ronald Garcia and Alison M. Clark and {\'E}ric Tanter},
  title     = {Abstracting Gradual Typing},
  booktitle = {Proceedings of the 43rd ACM SIGPLAN--SIGACT Symposium on Principles of Programming Languages (POPL)},
  year      = {2016},
  pages     = {429--442},
  publisher = {ACM},
  doi       = {10.1145/2837614.2837670}
}

@article{NewLicataAhmed2021,
  author    = {Max S. New and Daniel R. Licata and Amal Ahmed},
  title     = {Gradual Type Theory},
  journal   = {Journal of Functional Programming},
  volume    = {31},
  pages     = {e21},
  year      = {2021},
  doi       = {10.1017/S0956796821000125}
}

@article{BanadosSchwerterGarciaTanter2016,
  author    = {Felipe Ba{\~n}ados Schwerter and Ronald Garcia and {\'E}ric Tanter},
  title     = {Gradual Type-and-Effect Systems},
  journal   = {Journal of Functional Programming},
  volume    = {26},
  pages     = {e19},
  year      = {2016},
  doi       = {10.1017/S0956796816000162}
}

@inproceedings{ThiemannFennell2014,
  author    = {Peter Thiemann and Luminous Fennell},
  title     = {Gradual Typing for Annotated Type Systems},
  booktitle = {Programming Languages and Systems (ESOP 2014)},
  series    = {Lecture Notes in Computer Science},
  volume    = {8410},
  pages     = {47--66},
  publisher = {Springer},
  year      = {2014},
  doi       = {10.1007/978-3-642-54833-8_4}
}

@inproceedings{WadlerFindler2009,
  author    = {Philip Wadler and Robert Bruce Findler},
  title     = {Well-Typed Programs Can't Be Blamed},
  booktitle = {Programming Languages and Systems (ESOP 2009)},
  series    = {Lecture Notes in Computer Science},
  volume    = {5502},
  pages     = {1--16},
  publisher = {Springer},
  year      = {2009},
  doi       = {10.1007/978-3-642-00590-9_1}
}

@inproceedings{AhmedFindlerSiekWadler2011,
  author    = {Amal Ahmed and Robert Bruce Findler and Jeremy G. Siek and Philip Wadler},
  title     = {Blame for All},
  booktitle = {Proceedings of the 38th ACM SIGPLAN--SIGACT Symposium on Principles of Programming Languages (POPL)},
  year      = {2011},
  pages     = {201--214},
  publisher = {ACM},
  doi       = {10.1145/1926385.1926409}
}

@inproceedings{WrigstadEtAl2010,
  author    = {Tobias Wrigstad and Francesco Zappa Nardelli and Sylvain Lebresne and Johan \"{O}stlund and Jan Vitek},
  title     = {Integrating Typed and Untyped Code in a Scripting Language},
  booktitle = {Proceedings of the 37th ACM SIGPLAN--SIGACT Symposium on Principles of Programming Languages (POPL)},
  year      = {2010},
  pages     = {377--388},
  publisher = {ACM},
  doi       = {10.1145/1706299.1706343}
}

@inproceedings{CartwrightFagan1991,
  author    = {Robert Cartwright and Mike Fagan},
  title     = {Soft Typing},
  booktitle = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
  year      = {1991},
  pages     = {278--292},
  publisher = {ACM},
  doi       = {10.1145/113445.113469}
}

@inproceedings{Thatte1990,
  author    = {Satish R. Thatte},
  title     = {Quasi-Static Typing},
  booktitle = {Proceedings of the 17th ACM SIGPLAN--SIGACT Symposium on Principles of Programming Languages (POPL)},
  year      = {1990},
  pages     = {367--381},
  publisher = {ACM},
  doi       = {10.1145/96709.96747}
}

@inproceedings{CousotCousot1977,
  author    = {Patrick Cousot and Radhia Cousot},
  title     = {Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
  booktitle = {Proceedings of the 4th ACM SIGACT--SIGPLAN Symposium on Principles of Programming Languages (POPL)},
  year      = {1977},
  pages     = {238--252},
  publisher = {ACM},
  doi       = {10.1145/512950.512973}
}

@article{SuCulpepper2024,
  author    = {Chao Su and Justin Culpepper},
  title     = {Static Blame for Gradual Typing},
  journal   = {Journal of Functional Programming},
  volume    = {34},
  pages     = {e25},
  year      = {2024},
  note      = {First published online},
  doi       = {10.1017/S0956796824000194}
}
@article{10.1145/1328897.1328486,
author = {Tobin-Hochstadt, Sam and Felleisen, Matthias},
title = {The design and implementation of typed scheme},
year = {2008},
issue_date = {January 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1328897.1328486},
doi = {10.1145/1328897.1328486},
abstract = {When scripts in untyped languages grow into large programs, maintaining them becomes difficult. A lack of types in typical scripting languages means that programmers must (re)discover critical pieces of design information every time they wish to change a program. This analysis step both slows down the maintenance process and may even introduce mistakes due to the violation of undiscovered invariants.This paper presents Typed Scheme, an explicitly typed extension of an untyped scripting language. Its type system is based on the novel notion of occurrence typing, which we formalize and mechanically prove sound. The implementation of Typed Scheme additionally borrows elements from a range of approaches, including recursive types, true unions and subtyping, plus polymorphism combined with a modicum of local inference. Initial experiments with the implementation suggest that Typed Scheme naturally accommodates the programming style of the underlying scripting language, at least for the first few thousand lines of ported code.},
journal = {SIGPLAN Not.},
month = jan,
pages = {395–406},
numpages = {12},
keywords = {type systems, scheme}
}

@inproceedings{MauborgneRival2005,
  title={Trace partitioning in abstract interpretation based static analyzers},
  author={Mauborgne, Laurent and Rival, Xavier},
  booktitle={European Symposium on Programming},
  pages={5--20},
  year={2005},
  organization={Springer}
}

@inproceedings{TobinHochstadtFelleisen2008,
author = {Tobin-Hochstadt, Sam and Felleisen, Matthias},
title = {The design and implementation of typed scheme},
year = {2008},
isbn = {9781595936899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1328438.1328486},
doi = {10.1145/1328438.1328486},
abstract = {When scripts in untyped languages grow into large programs, maintaining them becomes difficult. A lack of types in typical scripting languages means that programmers must (re)discover critical pieces of design information every time they wish to change a program. This analysis step both slows down the maintenance process and may even introduce mistakes due to the violation of undiscovered invariants.This paper presents Typed Scheme, an explicitly typed extension of an untyped scripting language. Its type system is based on the novel notion of occurrence typing, which we formalize and mechanically prove sound. The implementation of Typed Scheme additionally borrows elements from a range of approaches, including recursive types, true unions and subtyping, plus polymorphism combined with a modicum of local inference. Initial experiments with the implementation suggest that Typed Scheme naturally accommodates the programming style of the underlying scripting language, at least for the first few thousand lines of ported code.},
booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {395–406},
numpages = {12},
keywords = {scheme, type systems},
location = {San Francisco, California, USA},
series = {POPL '08}
}

@article{DenningDenning1977,
  author    = {Dorothy E. Denning and Peter J. Denning},
  title     = {Certification of Programs for Secure Information Flow},
  journal   = {Communications of the ACM},
  volume    = {20},
  number    = {7},
  pages     = {504--513},
  year      = {1977},
  doi       = {10.1145/359636.359712}
}

@article{SabelfeldMyers2003,
  author    = {Andrei Sabelfeld and Andrew C. Myers},
  title     = {Language-Based Information-Flow Security},
  journal   = {IEEE Journal on Selected Areas in Communications},
  volume    = {21},
  number    = {1},
  pages     = {5--19},
  year      = {2003},
  doi       = {10.1109/JSAC.2002.806121}
}

@book{Smith2009,
  author    = {Geoffrey Smith},
  title     = {On the Foundations of Quantitative Information Flow},
  booktitle = {Foundations of Software Science and Computational Structures (FoSSaCS 2009)},
  series    = {Lecture Notes in Computer Science},
  volume    = {5504},
  pages     = {288--302},
  publisher = {Springer},
  year      = {2009},
  doi       = {10.1007/978-3-642-00596-1_21}
}

@inproceedings{BeyerHenzinger2007,
author = {Beyer, Dirk and Henzinger, Thomas A. and Th\'{e}oduloz, Gr\'{e}gory},
title = {Configurable software verification: concretizing the convergence of model checking and program analysis},
year = {2007},
isbn = {9783540733676},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {In automatic software verification, we have observed a theoretical convergence of model checking and program analysis. In practice, however, model checkers are still mostly concerned with precision, e.g., the removal of spurious counterexamples; for this purpose they build and refine reachability trees. Lattice-based program analyzers, on the other hand, are primarily concerned with efficiency. We designed an algorithm and built a tool that can be configured to perform not only a purely tree-based or a purely lattice-based analysis, but offers many intermediate settings that have not been evaluated before. The algorithm and tool take one or more abstract interpreters, such as a predicate abstraction and a shape analysis, and configure their execution and interaction using several parameters. Our experiments show that such customization may lead to dramatic improvements in the precision-efficiency spectrum.},
booktitle = {Proceedings of the 19th International Conference on Computer Aided Verification},
pages = {504–518},
numpages = {15},
location = {Berlin, Germany},
series = {CAV'07}
}
