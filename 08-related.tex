\section{Related Work}
\label{sec:related}

\paragraph{Gradual typing and its foundations.}
Gradual typing provides a principled account of mixing static and dynamic typing \cite{SiekTaha2006}. Subsequent work articulated meta-theoretic criteria such as the \emph{Gradual Guarantee} and precision monotonicity \cite{SiekGarciaTaha2015}. \emph{Abstracting Gradual Typing (AGT)} recasts gradual typing via abstract interpretation, formulating a Galois connection between precise and gradual types and deriving typing and casts from abstraction/concretization \cite{GarciaClarkTanter2016}. More recently, \emph{Gradual Type Theory} axiomatizes casts, the dynamic type, and the gradual guarantee in a type-theoretic setting, supplying logical tools to reason about equivalence and optimization \cite{NewLicataAhmed2021}. Our proposal is deliberately cast-free and purely static: instead of a single collapsed unknown, we expose an \emph{unfolded} family (ranks) that measures analysis imprecision without altering operational semantics.

\paragraph{AGT versus unfolded unknowns.}
AGT uses a \emph{single} unknown ($?$) whose meaning is given by concretization to a set of precise types; consistency and casts are derived systematically from the abstraction. In our system, there is a \emph{countable family} $\Any^{0},\Any^{1},\ldots$ indexing \emph{assumption depth} in a purely static abstract domain: same-rank joins are conservative LUBs, and ranks increase only at base-demand sites (downcasts). There is a simple erasure map $\mathrm{erase}(X^{i})=X$ and $\mathrm{erase}(\Any^{i})=?$ that embeds our types into AGT’s gradual types; conversely, all $\Any^{i}$ lie over the same AGT unknown, so ranks add provenance information orthogonal to AGT’s precision preorder. Thus our system can be viewed as an \emph{unfolded} static stratum of AGT (no runtime casts), with ranks recording where/how many assumptions were forced.

\paragraph{Gradual effect and annotation systems.}
Generalizations beyond simple types include gradual type-and-effect systems \cite{BanadosSchwerterGarciaTanter2016} and frameworks for gradualizing annotated type systems \cite{ThiemannFennell2014}. These quantify imprecision via a \emph{single} unknown element ($?$) and a consistency relation. In contrast, our ranks stratify imprecision arithmetically, recording how many assumptions were needed, while retaining a conventional join-semilattice discipline.

\paragraph{Blame calculi and static blame.}
The blame calculus connects gradual/hybrid typing with higher-order contracts and proves the blame theorem: when casts fail, responsibility lies on the less-precisely typed side \cite{WadlerFindler2009}; polymorphic extensions preserve these guarantees \cite{AhmedFindlerSiekWadler2011}. More recently, \emph{static blame} predicts potential blame without executing programs \cite{SuCulpepper2024}. Our setting shares the diagnostic spirit but introduces neither casts nor contract boundaries; the rank is a static, flow-sensitive measure of precision loss at control-flow joins and later downcasts.

\paragraph{Soft and quasi-static typing.}
Soft typing \cite{CartwrightFagan1991} and quasi-static typing \cite{Thatte1990} prefigure many aims of gradual typing: inferring permissive types and inserting checks as needed (often around a greatest element such as $\Omega$ or \textsf{Dyn}). By contrast, our analysis remains fully static and is not a source-to-source transformation; quantitative information is recorded as a rank in the abstract domain rather than materialized as runtime checks.

\paragraph{Typed/untyped interoperation via ``like'' types.}
Thorn’s \emph{like types} enable fine-grained interoperation between typed and untyped code while retaining optimization potential in typed regions \cite{WrigstadEtAl2010}. This is complementary: it proposes language constructs and runtime checks for interoperability, whereas we supply a static accounting of precision loss that can inform where such boundaries matter.

\paragraph{Abstract interpretation.}
Methodologically, our analysis is a standard monotone, flow-sensitive abstract interpretation \cite{CousotCousot1977}. The novelty lies in the abstract domain: an \emph{unfolded} per-program slice in which the conservative same-rank join is the LUB and rank increases only at finitely many base-demand sites (idempotent per site). Thus fixed points exist without bespoke widenings, and the diagnostic information (ranks and culprit sites) is exposed rather than collapsed.
