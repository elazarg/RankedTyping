\section{Language and Abstract Interpretation}
\label{sec:lang-ai}

We use a standard \textsf{while}-language with integers, strings, and booleans. Runtime semantics are conventional and ungraded; grades appear only in the abstract domain of \S\ref{sec:types}.

\subsection{Syntax and Concrete Semantics}

\begin{figure}[t]
\centering
\[
\begin{array}{rcll}
v &::=& n \in \mathbb{Z} \;\mid\; s \in \Sigma^* \;\mid\; \mathsf{true} \;\mid\; \mathsf{false} & \text{(values)}\\[1pt]
e &::=& v \;\mid\; x \;\mid\; e{+}e \;\mid\; \neg e \;\mid\; e \wedge e \;\mid\; e {=} e & \text{(expressions)}\\[1pt]
s &::=& \mathsf{skip} \;\mid\; x {:=} e \;\mid\; s; s \;\mid\; \mathsf{if}\; e\;\mathsf{then}\; s\;\mathsf{else}\; s \;\mid\; \mathsf{while}\; e\;\mathsf{do}\; s & \text{(statements)}
\end{array}
\]
\vspace{-2mm}
\caption{Syntax of the \textsf{while}-language.}
\label{fig:syntax-while}
\end{figure}

A \emph{state} is a total map $\sigma: \Var \to (\mathbb{Z}\cup\Sigma^*\cup\{\mathsf{true},\mathsf{false}\})$.
We write $\langle e,\sigma\rangle \Downarrow v$ for big-step expression evaluation and
$\langle s,\sigma\rangle \Downarrow \sigma'$ for statement evaluation. The rules are standard and deterministic:
(i) $x$ looks up $\sigma(x)$; (ii) $+$ denotes integer addition on integers and string concatenation on strings;
(iii) $\neg,\wedge$ operate on booleans; (iv) $=$ compares values for equality and yields a boolean; (v) assignments update the state; (vi) sequencing, conditional, and while follow the textbook rules, with $\mathsf{while}\;e\;\mathsf{do}\;s$ defined via the usual unrolling into an \textsf{if}.
We omit the routine rule schemata for space.

\subsection{Abstract Interpretation}

We interpret programs over the graded type lattice of \S\ref{sec:types}.
An \emph{abstract environment} is a map $\Gamma:\Var\to\tau$.
Ordering and joins on environments are pointwise, using the subtyping $\le$ and join $\sqcup$ on types defined previously.

\paragraph{Grade-aware coercion to a base.}
For $X\in\{\Int,\String,\Bool\}$ and a type $\tau$, define the \emph{least $X$-supertype} by
\[
\ceil{\tau}_X \;=\; \min\nolimits_{\le}\,\{\,X^{k}\mid \tau \le X^{k}\,\}.
\]
Under the subtyping rules of Fig.~\ref{fig:subtyping}, $\ceil{\tau}_X$ always exists and is unique; intuitively, $\ceil{\cdot}_X$ ``raises'' $\tau$ to the nearest $X$-typed supertype (performing a downcast $\Any^{i}\!\le\!X^{i+1}$ exactly when needed).

\paragraph{Abstract expressions.}
We write $\Gamma \vdash e : \tau$ for abstract evaluation.

\begin{mathpar}
\inferrule*[right=(Lit)]
  { }
  { \Gamma \vdash n : \Int^{0} \qquad
    \Gamma \vdash s : \String^{0} \qquad
    \Gamma \vdash \mathsf{true} : \Bool^{0} \qquad
    \Gamma \vdash \mathsf{false} : \Bool^{0} }

\inferrule*[right=(Var)]
  { \Gamma(x)=\tau }
  { \Gamma \vdash x : \tau }

\inferrule*[right=(Sub)]
  { \Gamma \vdash e : \tau \quad \tau \le \tau' }
  { \Gamma \vdash e : \tau' }
\end{mathpar}

\noindent Operators coerce operands to the relevant base(s) using $\ceil{\cdot}_X$ and then combine grades via $\max$.
Each overloaded operator admits several per-base typing derivations; the abstract interpreter selects the \emph{most precise} result using a cost-based criterion.

\paragraph{Per-base derivations.}
For~$+$, there are two per-base rules (integer addition and string concatenation):

\begin{mathpar}
\inferrule*[right=(Plus$_\Int$)]
  { \Gamma \vdash e_1:\tau_1 \quad \Gamma \vdash e_2:\tau_2 \\
    \ceil{\tau_1}_\Int = \Int^{i} \quad \ceil{\tau_2}_\Int = \Int^{j} }
  { \Gamma \vdash e_1{+}e_2 : \Int^{\max(i,j)} }

\inferrule*[right=(Plus$_\String$)]
  { \Gamma \vdash e_1:\tau_1 \quad \Gamma \vdash e_2:\tau_2 \\
    \ceil{\tau_1}_\String = \String^{i} \quad \ceil{\tau_2}_\String = \String^{j} }
  { \Gamma \vdash e_1{+}e_2 : \String^{\max(i,j)} }
\end{mathpar}

\noindent Similarly, equality admits three per-base rules (one for each of $\Int$, $\String$, $\Bool$):

\begin{mathpar}
\inferrule*[right=(Eq$_X$)]
  { X\in\{\Int,\String,\Bool\} \\
    \Gamma \vdash e_1:\tau_1 \quad \Gamma \vdash e_2:\tau_2 \\
    \ceil{\tau_1}_X = X^{i} \quad \ceil{\tau_2}_X = X^{j} }
  { \Gamma \vdash e_1 {=} e_2 : \Bool^{\max(i,j)} }
\end{mathpar}

\paragraph{Coercion cost and interpretation selection.}
Each per-base derivation requires coercing the operands to a common base~$X$. Define the \emph{coercion cost} of a type~$\tau$ with respect to base~$X$:
\[
\cost{X}(\tau) \;=\;
\begin{cases}
0 & \text{if } \tau = X^{i} \text{ for some } i,\\
1 & \text{otherwise.}
\end{cases}
\]
The \emph{total cost} of an interpretation under base~$X$ with operands $\tau_1,\tau_2$ is $\cost{X}(\tau_1)+\cost{X}(\tau_2)$.
The abstract interpreter selects the interpretation(s) with minimum total cost.
When the minimum is achieved by a unique base, that base's result is returned; when multiple bases tie, their results are joined:

\begin{mathpar}
\inferrule*[right=(Plus-Select)]
  { \mathcal{B} = \{\Int,\String\} \\[2pt]
    \text{For each } X\in\mathcal{B}\!:\;
    \Gamma \vdash e_1{+}e_2 : \tau_X \text{ via (Plus$_X$)}
    \;\;\text{with total cost } c_X \\[2pt]
    c^* = \min_{X\in\mathcal{B}} c_X \qquad
    \mathcal{B}^* = \{X\in\mathcal{B}\mid c_X = c^*\} }
  { \Gamma \vdash e_1{+}e_2 : \bigsqcup_{X\in\mathcal{B}^*}\!\tau_X }

\inferrule*[right=(Eq-Select)]
  { \mathcal{B} = \{\Int,\String,\Bool\} \\[2pt]
    \text{For each } X\in\mathcal{B}\!:\;
    \Gamma \vdash e_1{=}e_2 : \rho_X \text{ via (Eq$_X$)}
    \;\;\text{with total cost } c_X \\[2pt]
    c^* = \min_{X\in\mathcal{B}} c_X \qquad
    \mathcal{B}^* = \{X\in\mathcal{B}\mid c_X = c^*\} }
  { \Gamma \vdash e_1{=}e_2 : \bigsqcup_{X\in\mathcal{B}^*}\!\rho_X }
\end{mathpar}

\noindent\emph{Intuition.} When both operands are already of a given base (e.g., both $\Int^{i}$), the cost for that base is~$0$ while all other bases require coercions (cost~$\ge 1$). The operator therefore returns the matching base at no grade increase. Only when no single base is free---e.g., both operands are $\Any^{0}$---do multiple interpretations tie (all at cost~$1$ each), and their join produces $\Any$.

\emph{Admissibility.} The old ``join all'' rule (always joining every per-base derivation) is derivable via~(Sub), since each per-base result is a subtype of the join of all results. Cost-based selection is therefore a \emph{refinement}: it never produces a type above what ``join all'' would produce, but it often produces a strictly more precise one. The result is a \emph{principal} (most precise) abstract type for overloaded operators.

\begin{mathpar}
\inferrule*[right=(Not)]
  { \Gamma \vdash e:\tau \quad \ceil{\tau}_\Bool=\Bool^{i} }
  { \Gamma \vdash \neg e : \Bool^{i} }
\qquad
\inferrule*[right=(And)]
  { \Gamma \vdash e_1:\tau_1 \quad \Gamma \vdash e_2:\tau_2 \\
    \ceil{\tau_1}_\Bool=\Bool^{i} \quad \ceil{\tau_2}_\Bool=\Bool^{j} }
  { \Gamma \vdash e_1 \wedge e_2 : \Bool^{\max(i,j)} }
\end{mathpar}

\paragraph{Abstract statements.}
We write $\Gamma \vdash s \triangleright \Gamma'$ for the abstract transformer.

\begin{mathpar}
\inferrule*[right=(Skip)]
  { }
  { \Gamma \vdash \mathsf{skip} \triangleright \Gamma }

\inferrule*[right=(Assign)]
  { \Gamma \vdash e : \tau }
  { \Gamma \vdash x {:=} e \triangleright \Gamma[x \mapsto \tau] }

\inferrule*[right=(Seq)]
  { \Gamma \vdash s_1 \triangleright \Gamma_1 \quad
    \Gamma_1 \vdash s_2 \triangleright \Gamma_2 }
  { \Gamma \vdash s_1; s_2 \triangleright \Gamma_2 }

\inferrule*[right=(If)]
  { \Gamma \vdash e : \tau \quad \ceil{\tau}_\Bool=\Bool^{i} \\
    \Gamma \vdash s_1 \triangleright \Gamma_1 \quad
    \Gamma \vdash s_2 \triangleright \Gamma_2 }
  { \Gamma \vdash \mathsf{if}\; e\;\mathsf{then}\; s_1\;\mathsf{else}\; s_2
      \triangleright (\Gamma_1 \sqcup \Gamma_2) }
\end{mathpar}

\noindent Loops are defined as least fixed points of a monotone functional.

\begin{mathpar}
\inferrule*[right=(While)]
  { \text{Define } F(\Delta) \;=\; \Gamma \;\sqcup\; \Delta_{\!b}
      \text{ where } \Delta \vdash e:\tau,\ \ceil{\tau}_\Bool=\Bool^{i},\
      \Delta \vdash s \triangleright \Delta_{\!b} \\
    \Gamma^\star \text{ is the least fixed point of } F }
  { \Gamma \vdash \mathsf{while}\; e\;\mathsf{do}\; s \triangleright \Gamma^\star }
\end{mathpar}

\paragraph{Remarks.}
All joins are those of \S\ref{sec:types} (promotion to a common grade followed by same-grade join).
Because programs have finitely many join sites and grades increase only at downcasts (which occur at finitely many use sites), the per-program abstract domain reachable by iteration is finite up to the programâ€™s control-flow structure; hence Kleene iteration terminates without an additional widening.

\paragraph{Per-site idempotence (transfer-local).}
Let $T_q$ be the abstract transfer at a fixed program point $q$.
Then $T_q$ is idempotent: for all environments $\Delta$, $T_q(T_q(\Delta)) = T_q(\Delta)$.
\emph{Sketch.} Each $T_q$ consists of pointwise joins and, where a primitive demands a base, a single application of $\ceil{\cdot}_X$, which either leaves the input unchanged or performs exactly one downcast step $\Any^{i}\!\le\!X^{i+1}$; reapplying $T_q$ to the same input does not introduce a further increase.
(Iterated increases across \emph{different} inputs still require information from other sites, as captured by the fixed-point iteration.)
