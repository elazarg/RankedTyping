\section{Properties}
\label{sec:properties}

We collect algebraic and metatheoretic facts about the ranked-type algebra of \S\ref{sec:types}
(with subtyping generated by \textsc{(rank)} $X^{i}\le \mathsf{Any}^{i}$ and \textsc{(Step)} $\mathsf{Any}^{i}\le X^{i+1}$ for $i\in\mathbb{N}$ and $X\in\{\mathsf{Int},\mathsf{String},\mathsf{Bool}\}$),
and about the abstract interpretation of \S\ref{sec:lang-ai}.
When proofs are immediate from the order structure, we group them;
when nontrivial-but-easy, we give a short prose argument;
when false or unknown, we say so explicitly.

\subsection{Order-theoretic facts (types and subtyping)}
\paragraph{Poset structure.}
\begin{itemize}
\item \textbf{Reflexivity and transitivity} of $\le$ hold by construction (least reflexive--transitive closure).
\item \textbf{Antisymmetry} holds: if $\tau_1\le \tau_2$ and $\tau_2\le \tau_1$, then $\tau_1=\tau_2$.
\emph{Sketch.} Edges only go ``up'' within a rank ($X^{i}\to \mathsf{Any}^{i}$) or to the next rank ($\mathsf{Any}^{i}\to X^{i+1}$).
There is no rule oriented downward, hence no nontrivial cycle.
\end{itemize}

\paragraph{Global height vs. per-program finiteness.}
\begin{itemize}
\item \textbf{Infinite ascending chains} exist in the global poset:
$X^{0} < \mathsf{Any}^{0} < X^{1} < \mathsf{Any}^{1} < \dots$.
\item \textbf{Per-program finiteness.} For any fixed program, the abstract interpretation in \S\ref{sec:lang-ai}
raises ranks only at finitely many syntactic join sites (control-flow choke points) and each site is idempotent.
Thus the reachable fragment of the poset is finite for that program (\S\ref{sec:ai-termination}).
\end{itemize}

\subsection{Algebra of the analysis join $\boldsymbol{\sqcup}$}
Recall $\sqcup$ is the analysis-time join defined in \S\ref{sec:types} by
promotion to a common rank $r=\max(\mathrm{rank}(\tau_1),\mathrm{rank}(\tau_2))$
followed by same-rank combination:
if both precise bases differ at rank $r$ it yields $\mathsf{Any}^{r+1}$; if any side is $\mathsf{Any}^{r}$ it absorbs.

\paragraph{Basic algebra.}
\begin{itemize}
\item \textbf{Associativity, commutativity, idempotence (ACI).} Holds.
\emph{Sketch.} Promotion to the common rank $r$ is symmetric and idempotent; the same-rank rules implement a two-level semilattice where $\mathsf{Any}^{r}$ is absorbing and distinct bases join to $\mathsf{Any}^{r+1}$. Straightforward case analysis establishes ACI.
\item \textbf{Monotonicity.} If $\tau_1\le\tau_1'$ then $\tau_1\sqcup \tau_2 \le \tau_1'\sqcup \tau_2$.
\emph{Sketch.} Either ranks are unchanged (promotion unchanged) or the left operand promotes to a weaker (\emph{larger}) element at the common rank, which can only keep or raise the result in $\le$.
\end{itemize}

\paragraph{Absorption and promotion laws.}
For $i\le j$ and $X\in\{\mathsf{Int},\mathsf{String},\mathsf{Bool}\}$:
\[
\mathsf{Any}^{i}\sqcup \tau^{i}=\mathsf{Any}^{i},\qquad
\mathsf{Any}^{i}\sqcup \tau^{j}=\mathsf{Any}^{j},\qquad
X^{i}\sqcup Y^{i}=\mathsf{Any}^{i+1}\ (X\neq Y).
\]
All are immediate from the definition (promote to the higher rank then apply same-rank rules).

\paragraph{Not a LUB for $\le$.}
\emph{False.} $\sqcup$ is \underline{not} the least upper bound w.r.t.\ $\le$ in general.
Counterexample: at rank $0$,
$\mathsf{Int}^{0}\sqcup \mathsf{String}^{0}=\mathsf{Any}^{1}$,
while $\mathsf{Any}^{0}$ is an upper bound smaller than $\mathsf{Any}^{1}$ in $\le$ (since $\mathsf{Int}^{0}\le\mathsf{Any}^{0}$ and $\mathsf{String}^{0}\le\mathsf{Any}^{0}\le \mathsf{Int}^{1}\le \mathsf{Any}^{1}$).
Thus $\sqcup$ is an \emph{analysis join}, not the $\le$-LUB.

\subsection{Typing meta-theory (core expressions)}
We summarize properties for the expression fragment (no statements); proofs are standard unless noted.

\paragraph{Decidability and principal results.}
\begin{itemize}
\item \textbf{Decidability of typing.} Holds by structural recursion on expressions.
\item \textbf{Principal types (least rank discipline).} 
\emph{Holds} if we adopt the convention that derivations use the \emph{least} admissible rank (no gratuitous subsumption).
Then every typable expression has a unique principal type up to $\le$.
\emph{Note.} Without that discipline, multiple incomparable ranks may be derivable; principal typing can \emph{fail}.
\end{itemize}

\paragraph{Canonical forms (bases only).}
If $\vdash v:\mathsf{Int}^{i}$ then $v$ is an integer literal;
if $\vdash v:\mathsf{String}^{i}$ then $v$ is a string literal;
if $\vdash v:\mathsf{Bool}^{i}$ then $v\in\{\mathsf{true},\mathsf{false}\}$.
(Immediate from the literal rules.)

\paragraph{Progress and preservation (expressions).}
\begin{itemize}
\item \textbf{Progress.} Holds for closed, well-typed expressions in the base fragment: a term is either a value or reduces.
\item \textbf{Preservation.} Holds for expression reduction: if $\Gamma\vdash e:\tau$ and $e\to e'$, then $\Gamma\vdash e':\tau$.
\emph{Proof sketch.} Standard case analysis; ranks annotate types but do not alter operational rules. 
\end{itemize}

\paragraph{No global safety guarantee.}
\emph{False.} The system does \emph{not} ensure ``no run-time type error'' for full programs:
path-insensitive analysis can accept programs that go wrong at runtime (e.g.\ the ``swapped addends'' example).
This is by design; ranks record precision loss, not safety.

\subsection{Abstract interpretation properties}
We regard the statement transformer of \S\ref{sec:lang-ai} as a monotone functional on abstract environments.

\paragraph{Monotonicity of transfer.}
\textbf{Holds.} Each constructor is monotone in its arguments w.r.t.\ $\le$ and $\sqcup$.
Thus the overall program transformer is monotone.

\paragraph{Existence of least fixed points.}
\textbf{Holds.} The Kleene sequence from any $\Gamma$ under the monotone transformer converges to a least fixed point in finitely many steps \emph{for each program}.
\emph{Reason.} Although the global poset has infinite height, the abstract execution can only raise ranks at finitely many join sites and each site is idempotent (revisiting does not increase rank).
Hence the image set is finite and iteration stabilizes.

\paragraph{Over-approximation soundness (bases).}
\textbf{Holds (as a may-analysis).} 
Let $\Gamma \vdash s \triangleright \Gamma'$ and $\langle s,\sigma\rangle \Downarrow \sigma'$.
For each variable $x$, if $\Gamma'(x)$ has base $X$ (ignoring rank), then \emph{either}
$\sigma'(x)$ is a value of base $X$, \emph{or} the concrete run encountered a type mismatch at some use site where the analysis had previously raised to $\mathsf{Any}$.
\emph{Sketch.} At every operator, the abstract rules admit only those base interpretations that are reachable by (possibly increasing) to the least $X$-supertypes and joining.
A mismatch at runtime implies that at least one operand flowed through an analysis-time $\mathsf{Any}$ at some earlier join.

\paragraph{Bounded blame via ghost sets.}
\textbf{Holds.} Instrument the analysis with ghost sets $R_x\subseteq J$ for each variable $x$ (where $J$ is the finite set of program join sites); at a join $j$, set $R_x \leftarrow R_x^{\mathrm{then}}\cup R_x^{\mathrm{else}}\cup\{j\}$ pointwise.
If a concrete run faults at a use of operands $\vec{e}$ at program point $p$, then some $j$ in $\bigcup R_{\vec{e}}(p)$ lies on the reaching-use history of a faulting operand.
Hence the number of candidate sites to inspect is bounded by $|\bigcup R_{\vec{e}}(p)|$.
(\emph{Proof sketch} as in the ghost-state argument: if no join site is recorded, operands remained precise and the checker would reject the ill-typed use.)

\subsection{Relationship to optional top}
If $\mathsf{Any}^{\infty}$ is included in the syntax (as in \S\ref{sec:types}), then trivially $\tau\le \mathsf{Any}^{\infty}$ for all $\tau$, and
$\tau\sqcup \mathsf{Any}^{\infty}=\mathsf{Any}^{\infty}$.
All previous properties remain valid.
If $\mathsf{Any}^{\infty}$ is \emph{not} included, there is no global top element.

\subsection{What is unknown or intentionally left open}
\begin{itemize}
\item \textbf{Gradual guarantee (precision monotonicity).} \emph{Unknown.}
Ranks encode precision loss counts; the usual gradual guarantee is not formulated for this algebra.
\item \textbf{Subject expansion (reverse preservation).} \emph{Generally false} for systems with subtyping; we do not attempt to rescue it here.
\item \textbf{Principal typings for full statements.} \emph{Unknown} beyond the least-rank discipline for expressions; sequencing and loops with joins may admit incomparable derivations without a canonical minimal environment unless one fixes a specific analysis schedule.
\end{itemize}

\subsection{Summary}
The subtyping order is a well-founded partial order; the analysis join $\sqcup$ is algebraically well-behaved (ACI, monotone) but is \emph{not} the $\le$-LUB.
The abstract interpreter is monotone and converges for each program without widening, yielding a sound may-analysis.
Ranks measure analysis-time loss of precision; they support a bounded-blame diagnostic but not a traditional safety theorem.
