\section{Properties}
\label{sec:properties}

We collect algebraic and metatheoretic facts about the graded-type algebra of \S\ref{sec:types}
(with subtyping generated by \textsc{(grade)} $X^{i}\le \Any^{i}$ and \textsc{(Step)} $\Any^{i}\le X^{i+1}$ for $i\in\mathbb{N}$ and $X\in\{\Int,\String,\Bool\}$),
and about the abstract interpretation of \S\ref{sec:lang-ai}.
When proofs are immediate from the order structure, we group them.
Where nontrivial-but-straightforward, we sketch the argument.
Where false or currently unsettled, we say so.

\subsection{Order-theoretic facts (types and subtyping)}

\paragraph{Poset structure.}
\begin{itemize}
\item \textbf{Reflexivity and transitivity} of $\le$ hold by construction (least reflexive–transitive closure).
\item \textbf{Antisymmetry.} If $\tau_1\le \tau_2$ and $\tau_2\le \tau_1$ then $\tau_1=\tau_2$.
\emph{Sketch.} The generators are oriented ``up'': within a grade ($X^{i}\to\Any^{i}$) or from grade $i$ to $i{+}1$ ($\Any^{i}\to X^{i+1}$). No generator points downward, so there are no nontrivial cycles.
\item \textbf{Infinite ascending chains (global).} The global order has $\cdots < X^{0} < \Any^{0} < X^{1} < \Any^{1} < \cdots$.
\end{itemize}

\paragraph{Join as LUB.}
The operator $\sqcup$ of \S\ref{sec:types} is defined as the \emph{least upper bound} w.r.t.\ $\le$.
\emph{Sketch.} Promotion to the common grade $r$ maps both arguments to least $r$-supertypes; the same-grade table then returns the least among their common $r$-supertypes (either a base $X^{r}$ when equal, or $\Any^{r}$ otherwise). Hence $\tau_1\sqcup\tau_2$ is the $\le$-LUB.

\paragraph{Basic algebraic laws.}
For all $i\le j$ and $X\in\{\Int,\String,\Bool\}$:
\[
\Any^{i}\le \Any^{j},\quad X^{i}\le X^{j},\qquad
\Any^{i}\sqcup \tau^{j}= \Any^{\max(i,j)},\qquad
X^{i}\sqcup Y^{i}=
\begin{cases}
X^{i} & (X=Y)\\
\Any^{i} & (X\neq Y)
\end{cases}
\]
Moreover, $\sqcup$ is associative, commutative, and idempotent (ACI).
All follow directly from the definition in Fig.~\ref{fig:join}.

\subsection{Typing meta-theory (core expressions)}

\paragraph{Decidability.}
Typing for expressions is decidable by structural recursion; subtyping checks are syntactic (the generated relation has a canonical decision procedure).

\paragraph{Principal types under least-grade discipline.}
If derivations always pick the \emph{least} admissible grade (no gratuitous subsumption), then every typable expression has a principal type unique up to $\le$.
Without this discipline, incomparable grades may be derivable; principal typing may fail.

\paragraph{Canonical forms (bases).}
If $\vdash v:\Int^{i}$ then $v$ is an integer literal; similarly for $\String^{i}$ and $\Bool^{i}$.

\paragraph{Progress and preservation (expressions).}
For the core expression fragment, progress and preservation hold with grades as annotations: if $\Gamma\vdash e:\tau$ and $e\to e'$ then $\Gamma\vdash e':\tau$.
(Operational rules are unchanged by grades.)

\paragraph{No global safety theorem.}
The analysis is a may-analysis; it does not rule out runtime type errors for full programs. Grades document precision loss; they do not enforce safety.

\subsection{Abstract interpretation: soundness, monotonicity, termination}

\paragraph{Monotonicity of transfer.}
All abstract expression and statement constructors are monotone in their inputs w.r.t.\ $\le$ (and pointwise on environments). In particular, $\ceil{\cdot}_X$ is monotone: $\tau\le\tau'$ implies $\ceil{\tau}_X \le \ceil{\tau'}_X$.

\paragraph{Soundness (may-analysis).}
Let $\alpha$ map concrete states to abstract environments by sending each concrete value to its base at grade $0$ and then closing upward under $\le$.
If $\alpha(\sigma)\le \Gamma$ and $\langle s,\sigma\rangle \Downarrow \sigma'$, and $\Gamma \vdash s \triangleright \Gamma'$, then $\alpha(\sigma') \le \Gamma'$.
\emph{Sketch.} By induction on the big-step derivation. Each operator coerces operands to the least base supertype via $\ceil{\cdot}_X$, which corresponds to taking an abstract upper bound; the join on environments is the LUB.

\paragraph{Termination.}
The global lattice has infinite height, so \emph{plain} Kleene iteration need not terminate in general (loops can propagate ever-increasing grades via repeated downcasts on rising $\Any^{k}$).
We give two standard remedies; either suffices.

\smallskip
\noindent\emph{(A) Grade-capping widening.}
Fix a finite cap $K$ (e.g., number of distinct base-demand sites in the program).
Define a widening $\nabla_K$ pointwise on types by
\[
X^{i}\ \nabla_K\ X^{j} \;=\; X^{\min(\max(i,j),K)},\qquad
\Any^{i}\ \nabla_K\ \Any^{j} \;=\; \Any^{\min(\max(i,j),K)},
\]
and extend homomorphically to mixed pairs via promotion then capping. Then the standard iteration with $\sqcup$ and occasional $\nabla_K$ applications converges in finitely many steps to a post-fixpoint.

\smallskip
\noindent\emph{(B) Ghost-set product domain (per-program finiteness).}
Augment each variable’s abstract value with a finite set $R\subseteq J$ of \emph{site IDs} (base-demand and join sites).
Update $R$ by union at joins and add the current site at each downcast.
Interpret the grade as $|R|$ (or any monotone function of $R$).
Since $J$ is finite, the $R$-component has finite height; iteration terminates.
The numeric grade exposed to users can be $\min(|R|,K)$ for a chosen cap $K$.

\smallskip
Either approach preserves soundness; (B) additionally supports precise diagnostics (below).

\paragraph{Attribution bound (grades by coercion sites).}
We formalize the intuition that grades count forced assumptions at uses.

\begin{definition}[Coercion-forcing site]
A program point $q$ (occurrence of a primitive or context demanding base $X$) is \emph{coercion-forcing} for a variable $x$ if, in the incoming environment $\Delta$ at $q$, some subexpression $e$ reads $x$ with type $\tau=\Delta(x)$ and $\ceil{\tau}_X > \tau$ in $\le$ (i.e., $x$ is not already of base $X$ at some grade).
In this case evaluating $T_q$ performs a downcast step contributing $+1$ to the grade of the result along that use.
\end{definition}

\begin{definition}[Pathwise coercion set]
For a program point $p$ and variable $x$, let $C_p(x)$ be the set of distinct coercion-forcing sites for $x$ that occur on some control-flow path ending at $p$.
\end{definition}

\begin{theorem}[Attribution bound]
\label{thm:attribution}
Let $\Gamma_p$ be the least fixed-point environment at program point $p$.
Then for every variable $x$, if $\Gamma_p(x)$ has finite grade $r$, we have
\[
r \;\le\; |C_p(x)|.
\]
Moreover, if the analysis is instrumented to record the first visit to each coercion-forcing site (cf.\ §\ref{sec:properties}, Diagnostics), then every unit increase in $r$ is justified by some site in $C_p(x)$ (up to idempotence under repeated visits).
\emph{Sketch.} Induct on path length and fixed-point iteration.
Joins never raise grades; the only rule that increases grade is a coercion at a coercion-forcing site, which contributes at most $+1$ per distinct site.
Since paths to $p$ encounter only finitely many program points, the bound follows.
\end{theorem}

\subsection{Diagnostics: bounded blame via ghost sets}

\textbf{Instrument the analysis with ghost sets $R_x\subseteq J$ for each variable $x$ (where $J$ is the finite set of program sites that force a base after imprecision or merge flows).
At a join site $j$, set $R_x \leftarrow R_x^{\mathrm{then}}\cup R_x^{\mathrm{else}}\cup\{j\}$ pointwise.}
At a downcast site $k$, set $R_x \leftarrow R_x\cup\{k\}$.
If a concrete run faults at a use of operands $\vec{e}$ at program point $p$, then some $j\in \bigcup R_{\vec{e}}(p)$ lies on the reaching-use history of a faulting operand.
Thus the number of candidate sites to inspect is bounded by $|\bigcup R_{\vec{e}}(p)|$.

\subsection{Optional top}
If $\Any^{\infty}$ is included, then trivially $\tau\le \Any^{\infty}$ and $\tau\sqcup \Any^{\infty}=\Any^{\infty}$ for all $\tau$.
All properties above remain valid.
Without $\Any^{\infty}$, there is no global top.

\subsection{What is unknown or intentionally left open}
\begin{itemize}
\item \textbf{Gradual guarantee (precision monotonicity).} \emph{Open.}
Grades encode counts of assumptions; the usual gradual guarantee is formulated over a precision preorder and casts. A grade-indexed analogue remains to be stated and proved.
\item \textbf{Subject expansion (reverse preservation).} \emph{Generally false} in the presence of subtyping; we make no claim.
\item \textbf{Principal typings for full statements.} \emph{Open.} Fixed points and joins may admit incomparable environments unless a specific iteration schedule or widening is fixed.
\end{itemize}

\subsection{Summary}
$\langle\Types,\le,\sqcup\rangle$ forms a well-behaved join-semilattice; $\sqcup$ is the $\le$-LUB and ACI.
The abstract interpreter is monotone and sound as a may-analysis.
Termination requires either a simple grade-capping widening or a finite ghost-set product domain; both are standard and compatible with our diagnostics.
Grades quantify analysis-time precision loss and support bounded-blame localization but do not constitute a safety guarantee.
